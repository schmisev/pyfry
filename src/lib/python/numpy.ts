import { wrapAutocomplete } from "$lib/faux-language-server";
import { type Completion } from "@codemirror/autocomplete";

export const npCompletions: Completion[] = [
{ label: `np.empty(shape)`, displayLabel: `np.empty(shape[, dtype, order, device, like])`, info: `empty(shape[, dtype, order, device, like]):\nReturn a new array of given shape and type, without initializing entries.`, type: `function` },
{ label: `np.empty_like(prototype)`, displayLabel: `np.empty_like(prototype[, dtype, order, subok, ...])`, info: `empty_like(prototype[, dtype, order, subok, ...]):\nReturn a new array with the same shape and type as a given array.`, type: `function` },
{ label: `np.np.eye(N)`, displayLabel: `np.eye(N[, M, k, dtype, order, device, like])`, info: `eye(N[, M, k, dtype, order, device, like]):\nReturn a 2-D array with ones on the diagonal and zeros elsewhere.`, type: `function` },
{ label: `np.identity(n)`, displayLabel: `np.identity(n[, dtype, like])`, info: `identity(n[, dtype, like]):\nReturn the identity array.`, type: `function` },
{ label: `np.ones(shape)`, displayLabel: `np.ones(shape[, dtype, order, device, like])`, info: `ones(shape[, dtype, order, device, like]):\nReturn a new array of given shape and type, filled with ones.`, type: `function` },
{ label: `np.ones_like(a)`, displayLabel: `np.ones_like(a[, dtype, order, subok, shape, ...])`, info: `ones_like(a[, dtype, order, subok, shape, ...]):\nReturn an array of ones with the same shape and type as a given array.`, type: `function` },
{ label: `np.zeros(shape)`, displayLabel: `np.zeros(shape[, dtype, order, like])`, info: `zeros(shape[, dtype, order, like]):\nReturn a new array of given shape and type, filled with zeros.`, type: `function` },
{ label: `np.zeros_like(a)`, displayLabel: `np.zeros_like(a[, dtype, order, subok, shape, ...])`, info: `zeros_like(a[, dtype, order, subok, shape, ...]):\nReturn an array of zeros with the same shape and type as a given array.`, type: `function` },
{ label: `np.full(shape, fill_value)`, displayLabel: `np.full(shape, fill_value[, dtype, order, ...])`, info: `full(shape, fill_value[, dtype, order, ...]):\nReturn a new array of given shape and type, filled with fill_value.`, type: `function` },
{ label: `np.full_like(a, fill_value)`, displayLabel: `np.full_like(a, fill_value[, dtype, order, ...])`, info: `full_like(a, fill_value[, dtype, order, ...]):\nReturn a full array with the same shape and type as a given array.`, type: `function` },
{ label: `np.array(object)`, displayLabel: `np.array(object[, dtype, copy, order, subok, ...])`, info: `array(object[, dtype, copy, order, subok, ...]):\nCreate an array.`, type: `function` },
{ label: `np.asarray(a)`, displayLabel: `np.asarray(a[, dtype, order, device, copy, like])`, info: `asarray(a[, dtype, order, device, copy, like]):\nConvert the input to an array.`, type: `function` },
{ label: `np.asanyarray(a)`, displayLabel: `np.asanyarray(a[, dtype, order, device, copy, like])`, info: `asanyarray(a[, dtype, order, device, copy, like]):\nConvert the input to an ndarray, but pass ndarray subclasses through.`, type: `function` },
{ label: `np.ascontiguousarray(a)`, displayLabel: `np.ascontiguousarray(a[, dtype, like])`, info: `ascontiguousarray(a[, dtype, like]):\nReturn a contiguous array (ndim >= 1) in memory (C order).`, type: `function` },
{ label: `np.asmatrix(data)`, displayLabel: `np.asmatrix(data[, dtype])`, info: `asmatrix(data[, dtype]):\nInterpret the input as a matrix.`, type: `function` },
{ label: `np.astype(x, dtype)`, displayLabel: `np.astype(x, dtype, *[, copy, device])`, info: `astype(x, dtype, *[, copy, device]):\nCopies an array to a specified data type.`, type: `function` },
{ label: `np.copy(a)`, displayLabel: `np.copy(a[, order, subok])`, info: `copy(a[, order, subok]):\nReturn an array copy of the given object.`, type: `function` },
{ label: `np.frombuffer(buffer)`, displayLabel: `np.frombuffer(buffer[, dtype, count, offset, like])`, info: `frombuffer(buffer[, dtype, count, offset, like]):\nInterpret a buffer as a 1-dimensional array.`, type: `function` },
{ label: `np.from_dlpack(x)`, displayLabel: `np.from_dlpack(x, *[, device, copy])`, info: `from_dlpack(x, *[, device, copy]):\nCreate a NumPy array from an object implementing the __dlpack__ protocol.`, type: `function` },
{ label: `np.fromfile(file)`, displayLabel: `np.fromfile(file[, dtype, count, sep, offset, like])`, info: `fromfile(file[, dtype, count, sep, offset, like]):\nConstruct an array from data in a text or binary file.`, type: `function` },
{ label: `np.fromfunction(function, shape, *)`, displayLabel: `np.fromfunction(function, shape, *[, dtype, like])`, info: `fromfunction(function, shape, *[, dtype, like]):\nConstruct an array by executing a function over each coordinate.`, type: `function` },
{ label: `np.fromiter(iter, dtype)`, displayLabel: `np.fromiter(iter, dtype[, count, like])`, info: `fromiter(iter, dtype[, count, like]):\nCreate a new 1-dimensional array from an iterable object.`, type: `function` },
{ label: `np.fromstring(string)`, displayLabel: `np.fromstring(string[, dtype, count, like])`, info: `fromstring(string[, dtype, count, like]):\nA new 1-D array initialized from text data in a string.`, type: `function` },
{ label: `np.loadtxt(fname)`, displayLabel: `np.loadtxt(fname[, dtype, comments, delimiter, ...])`, info: `loadtxt(fname[, dtype, comments, delimiter, ...]):\nLoad data from a text file.`, type: `function` },
{ label: `np.char.array(obj)`, displayLabel: `np.char.array(obj[, itemsize, copy, unicode, order])`, info: `char.array(obj[, itemsize, copy, unicode, order]):\nCreate a chararray.`, type: `function` },
{ label: `np.char.asarray(obj)`, displayLabel: `np.char.asarray(obj[, itemsize, unicode, order])`, info: `char.asarray(obj[, itemsize, unicode, order]):\nConvert the input to a chararray, copying the data only if necessary.`, type: `function` },
{ label: `np.arange(start, stop, step)`, displayLabel: `np.arange([start,] stop[, step,][, dtype, ...])`, info: `arange([start,] stop[, step,][, dtype, ...]):\nReturn evenly spaced values within a given interval.`, type: `function` },
{ label: `np.linspace(start, stop)`, displayLabel: `np.linspace(start, stop[, num, endpoint, ...])`, info: `linspace(start, stop[, num, endpoint, ...]):\nReturn evenly spaced numbers over a specified interval.`, type: `function` },
{ label: `np.logspace(start, stop)`, displayLabel: `np.logspace(start, stop[, num, endpoint, base, ...])`, info: `logspace(start, stop[, num, endpoint, base, ...]):\nReturn numbers spaced evenly on a log scale.`, type: `function` },
{ label: `np.geomspace(start, stop)`, displayLabel: `np.geomspace(start, stop[, num, endpoint, ...])`, info: `geomspace(start, stop[, num, endpoint, ...]):\nReturn numbers spaced evenly on a log scale (a geometric progression).`, type: `function` },
{ label: `np.meshgrid(*xi)`, displayLabel: `np.meshgrid(*xi[, copy, sparse, indexing])`, info: `meshgrid(*xi[, copy, sparse, indexing]):\nReturn a tuple of coordinate matrices from coordinate vectors.`, type: `function` },
{ label: `np.mgrid`, displayLabel: `np.mgrid`, info: `mgrid:\nAn instance which returns a dense multi-dimensional "meshgrid".`, type: `function` },
{ label: `np.ogrid`, displayLabel: `np.ogrid`, info: `ogrid:\nAn instance which returns an open multi-dimensional "meshgrid".`, type: `function` },
{ label: `np.diag(v)`, displayLabel: `np.diag(v[, k])`, info: `diag(v[, k]):\nExtract a diagonal or construct a diagonal array.`, type: `function` },
{ label: `np.diagflat(v)`, displayLabel: `np.diagflat(v[, k])`, info: `diagflat(v[, k]):\nCreate a two-dimensional array with the flattened input as a diagonal.`, type: `function` },
{ label: `np.tri(N)`, displayLabel: `np.tri(N[, M, k, dtype, like])`, info: `tri(N[, M, k, dtype, like]):\nAn array with ones at and below the given diagonal and zeros elsewhere.`, type: `function` },
{ label: `np.tril(m)`, displayLabel: `np.tril(m[, k])`, info: `tril(m[, k]):\nLower triangle of an array.`, type: `function` },
{ label: `np.triu(m)`, displayLabel: `np.triu(m[, k])`, info: `triu(m[, k]):\nUpper triangle of an array.`, type: `function` },
{ label: `np.vander(x)`, displayLabel: `np.vander(x[, N, increasing])`, info: `vander(x[, N, increasing]):\nGenerate a Vandermonde matrix.`, type: `function` },
{ label: `np.bmat(obj)`, displayLabel: `np.bmat(obj[, ldict, gdict])`, info: `bmat(obj[, ldict, gdict]):\nBuild a matrix object from a string, nested sequence, or array.`, type: `function` },
{ label: `np.copyto(dst, src)`, displayLabel: `np.copyto(dst, src[, casting, where])`, info: `copyto(dst, src[, casting, where]):\nCopies values from one array to another, broadcasting as necessary.`, type: `function` },
{ label: `np.ndim(a)`, displayLabel: `np.ndim(a)`, info: `ndim(a):\nReturn the number of dimensions of an array.`, type: `function` },
{ label: `np.shape(a)`, displayLabel: `np.shape(a)`, info: `shape(a):\nReturn the shape of an array.`, type: `function` },
{ label: `np.size(a)`, displayLabel: `np.size(a[, axis])`, info: `size(a[, axis]):\nReturn the number of elements along a given axis.`, type: `function` },
{ label: `np.reshape(a)`, displayLabel: `np.reshape(a[, shape, order, newshape, copy])`, info: `reshape(a[, shape, order, newshape, copy]):\nGives a new shape to an array without changing its data.`, type: `function` },
{ label: `np.ravel(a)`, displayLabel: `np.ravel(a[, order])`, info: `ravel(a[, order]):\nReturn a contiguous flattened array.`, type: `function` },
{ label: `np.ndarray.flatten()`, displayLabel: `np.ndarray.flatten([order])`, info: `ndarray.flatten([order]):\nReturn a copy of the array collapsed into one dimension.`, type: `function` },
{ label: `np.moveaxis(a, source, destination)`, displayLabel: `np.moveaxis(a, source, destination)`, info: `moveaxis(a, source, destination):\nMove axes of an array to new positions.`, type: `function` },
{ label: `np.rollaxis(a, axis)`, displayLabel: `np.rollaxis(a, axis[, start])`, info: `rollaxis(a, axis[, start]):\nRoll the specified axis backwards, until it lies in a given position.`, type: `function` },
{ label: `np.swapaxes(a, axis1, axis2)`, displayLabel: `np.swapaxes(a, axis1, axis2)`, info: `swapaxes(a, axis1, axis2):\nInterchange two axes of an array.`, type: `function` },
{ label: `np.transpose(a)`, displayLabel: `np.transpose(a[, axes])`, info: `transpose(a[, axes]):\nReturns an array with axes transposed.`, type: `function` },
{ label: `np.permute_dims(a)`, displayLabel: `np.permute_dims(a[, axes])`, info: `permute_dims(a[, axes]):\nReturns an array with axes transposed.`, type: `function` },
{ label: `np.matrix_transpose(x)`, displayLabel: `np.matrix_transpose(x)`, info: `matrix_transpose(x):\nTransposes a matrix (or a stack of matrices) x.`, type: `function` },
{ label: `np.atleast_1d(*arys)`, displayLabel: `np.atleast_1d(*arys)`, info: `atleast_1d(*arys):\nConvert inputs to arrays with at least one dimension.`, type: `function` },
{ label: `np.atleast_2d(*arys)`, displayLabel: `np.atleast_2d(*arys)`, info: `atleast_2d(*arys):\nView inputs as arrays with at least two dimensions.`, type: `function` },
{ label: `np.atleast_3d(*arys)`, displayLabel: `np.atleast_3d(*arys)`, info: `atleast_3d(*arys):\nView inputs as arrays with at least three dimensions.`, type: `function` },
{ label: `np.broadcast`, displayLabel: `np.broadcast`, info: `broadcast:\nProduce an object that mimics broadcasting.`, type: `function` },
{ label: `np.broadcast_to(array, shape)`, displayLabel: `np.broadcast_to(array, shape[, subok])`, info: `broadcast_to(array, shape[, subok]):\nBroadcast an array to a new shape.`, type: `function` },
{ label: `np.broadcast_arrays(*args)`, displayLabel: `np.broadcast_arrays(*args[, subok])`, info: `broadcast_arrays(*args[, subok]):\nBroadcast any number of arrays against each other.`, type: `function` },
{ label: `np.expand_dims(a, axis)`, displayLabel: `np.expand_dims(a, axis)`, info: `expand_dims(a, axis):\nExpand the shape of an array.`, type: `function` },
{ label: `np.squeeze(a)`, displayLabel: `np.squeeze(a[, axis])`, info: `squeeze(a[, axis]):\nRemove axes of length one from a.`, type: `function` },
{ label: `np.asarray(a)`, displayLabel: `np.asarray(a[, dtype, order, device, copy, like])`, info: `asarray(a[, dtype, order, device, copy, like]):\nConvert the input to an array.`, type: `function` },
{ label: `np.asanyarray(a)`, displayLabel: `np.asanyarray(a[, dtype, order, device, copy, like])`, info: `asanyarray(a[, dtype, order, device, copy, like]):\nConvert the input to an ndarray, but pass ndarray subclasses through.`, type: `function` },
{ label: `np.asmatrix(data)`, displayLabel: `np.asmatrix(data[, dtype])`, info: `asmatrix(data[, dtype]):\nInterpret the input as a matrix.`, type: `function` },
{ label: `np.asfortranarray(a)`, displayLabel: `np.asfortranarray(a[, dtype, like])`, info: `asfortranarray(a[, dtype, like]):\nReturn an array (ndim >= 1) laid out in Fortran order in memory.`, type: `function` },
{ label: `np.ascontiguousarray(a)`, displayLabel: `np.ascontiguousarray(a[, dtype, like])`, info: `ascontiguousarray(a[, dtype, like]):\nReturn a contiguous array (ndim >= 1) in memory (C order).`, type: `function` },
{ label: `np.asarray_chkfinite(a)`, displayLabel: `np.asarray_chkfinite(a[, dtype, order])`, info: `asarray_chkfinite(a[, dtype, order]):\nConvert the input to an array, checking for NaNs or Infs.`, type: `function` },
{ label: `np.require(a)`, displayLabel: `np.require(a[, dtype, requirements, like])`, info: `require(a[, dtype, requirements, like]):\nReturn an ndarray of the provided type that satisfies requirements.`, type: `function` },
{ label: `np.concatenate()`, displayLabel: `np.concatenate([axis, out, dtype, casting])`, info: `concatenate([axis, out, dtype, casting]):\nJoin a sequence of arrays along an existing axis.`, type: `function` },
{ label: `np.concat()`, displayLabel: `np.concat([axis, out, dtype, casting])`, info: `concat([axis, out, dtype, casting]):\nJoin a sequence of arrays along an existing axis.`, type: `function` },
{ label: `np.stack(arrays)`, displayLabel: `np.stack(arrays[, axis, out, dtype, casting])`, info: `stack(arrays[, axis, out, dtype, casting]):\nJoin a sequence of arrays along a new axis.`, type: `function` },
{ label: `np.block(arrays)`, displayLabel: `np.block(arrays)`, info: `block(arrays):\nAssemble an nd-array from nested lists of blocks.`, type: `function` },
{ label: `np.vstack(tup, *)`, displayLabel: `np.vstack(tup, *[, dtype, casting])`, info: `vstack(tup, *[, dtype, casting]):\nStack arrays in sequence vertically (row wise).`, type: `function` },
{ label: `np.hstack(tup, *)`, displayLabel: `np.hstack(tup, *[, dtype, casting])`, info: `hstack(tup, *[, dtype, casting]):\nStack arrays in sequence horizontally (column wise).`, type: `function` },
{ label: `np.dstack(tup)`, displayLabel: `np.dstack(tup)`, info: `dstack(tup):\nStack arrays in sequence depth wise (along third axis).`, type: `function` },
{ label: `np.column_stack(tup)`, displayLabel: `np.column_stack(tup)`, info: `column_stack(tup):\nStack 1-D arrays as columns into a 2-D array.`, type: `function` },
{ label: `np.split(ary, indices_or_sections)`, displayLabel: `np.split(ary, indices_or_sections[, axis])`, info: `split(ary, indices_or_sections[, axis]):\nSplit an array into multiple sub-arrays as views into ary.`, type: `function` },
{ label: `np.array_split(ary, indices_or_sections)`, displayLabel: `np.array_split(ary, indices_or_sections[, axis])`, info: `array_split(ary, indices_or_sections[, axis]):\nSplit an array into multiple sub-arrays.`, type: `function` },
{ label: `np.dsplit(ary, indices_or_sections)`, displayLabel: `np.dsplit(ary, indices_or_sections)`, info: `dsplit(ary, indices_or_sections):\nSplit array into multiple sub-arrays along the 3rd axis (depth).`, type: `function` },
{ label: `np.hsplit(ary, indices_or_sections)`, displayLabel: `np.hsplit(ary, indices_or_sections)`, info: `hsplit(ary, indices_or_sections):\nSplit an array into multiple sub-arrays horizontally (column-wise).`, type: `function` },
{ label: `np.vsplit(ary, indices_or_sections)`, displayLabel: `np.vsplit(ary, indices_or_sections)`, info: `vsplit(ary, indices_or_sections):\nSplit an array into multiple sub-arrays vertically (row-wise).`, type: `function` },
{ label: `np.unstack(x)`, displayLabel: `np.unstack(x, *[, axis])`, info: `unstack(x, *[, axis]):\nSplit an array into a sequence of arrays along the given axis.`, type: `function` },
{ label: `np.tile(A, reps)`, displayLabel: `np.tile(A, reps)`, info: `tile(A, reps):\nConstruct an array by repeating A the number of times given by reps.`, type: `function` },
{ label: `np.repeat(a, repeats)`, displayLabel: `np.repeat(a, repeats[, axis])`, info: `repeat(a, repeats[, axis]):\nRepeat each element of an array after themselves`, type: `function` },
{ label: `np.delete(arr, obj)`, displayLabel: `np.delete(arr, obj[, axis])`, info: `delete(arr, obj[, axis]):\nReturn a new array with sub-arrays along an axis deleted.`, type: `function` },
{ label: `np.insert(arr, obj, values)`, displayLabel: `np.insert(arr, obj, values[, axis])`, info: `insert(arr, obj, values[, axis]):\nInsert values along the given axis before the given indices.`, type: `function` },
{ label: `np.append(arr, values)`, displayLabel: `np.append(arr, values[, axis])`, info: `append(arr, values[, axis]):\nAppend values to the end of an array.`, type: `function` },
{ label: `np.resize(a, new_shape)`, displayLabel: `np.resize(a, new_shape)`, info: `resize(a, new_shape):\nReturn a new array with the specified shape.`, type: `function` },
{ label: `np.trim_zeros(filt)`, displayLabel: `np.trim_zeros(filt[, trim, axis])`, info: `trim_zeros(filt[, trim, axis]):\nRemove values along a dimension which are zero along all other.`, type: `function` },
{ label: `np.unique(ar)`, displayLabel: `np.unique(ar[, return_index, return_inverse, ...])`, info: `unique(ar[, return_index, return_inverse, ...]):\nFind the unique elements of an array.`, type: `function` },
{ label: `np.pad(array, pad_width)`, displayLabel: `np.pad(array, pad_width[, mode])`, info: `pad(array, pad_width[, mode]):\nPad an array.`, type: `function` },
{ label: `np.flip(m)`, displayLabel: `np.flip(m[, axis])`, info: `flip(m[, axis]):\nReverse the order of elements in an array along the given axis.`, type: `function` },
{ label: `np.fliplr(m)`, displayLabel: `np.fliplr(m)`, info: `fliplr(m):\nReverse the order of elements along axis 1 (left/right).`, type: `function` },
{ label: `np.flipud(m)`, displayLabel: `np.flipud(m)`, info: `flipud(m):\nReverse the order of elements along axis 0 (up/down).`, type: `function` },
{ label: `np.roll(a, shift)`, displayLabel: `np.roll(a, shift[, axis])`, info: `roll(a, shift[, axis]):\nRoll array elements along a given axis.`, type: `function` },
{ label: `np.rot90(m)`, displayLabel: `np.rot90(m[, k, axes])`, info: `rot90(m[, k, axes]):\nRotate an array by 90 degrees in the plane specified by axes.`, type: `function` },
{ label: `np.bitwise_and(x1, x2)`, displayLabel: `np.bitwise_and(x1, x2[, out, where, ...])`, info: `bitwise_and(x1, x2[, out, where, ...]):\nCompute the bit-wise AND of two arrays element-wise.`, type: `function` },
{ label: `np.bitwise_or(x1, x2)`, displayLabel: `np.bitwise_or(x1, x2[, out, where, casting, ...])`, info: `bitwise_or(x1, x2[, out, where, casting, ...]):\nCompute the bit-wise OR of two arrays element-wise.`, type: `function` },
{ label: `np.bitwise_xor(x1, x2)`, displayLabel: `np.bitwise_xor(x1, x2[, out, where, ...])`, info: `bitwise_xor(x1, x2[, out, where, ...]):\nCompute the bit-wise XOR of two arrays element-wise.`, type: `function` },
{ label: `np.invert(x)`, displayLabel: `np.invert(x[, out, where, casting, order, ...])`, info: `invert(x[, out, where, casting, order, ...]):\nCompute bit-wise inversion, or bit-wise NOT, element-wise.`, type: `function` },
{ label: `np.bitwise_invert(x)`, displayLabel: `np.bitwise_invert(x[, out, where, casting, ...])`, info: `bitwise_invert(x[, out, where, casting, ...]):\nCompute bit-wise inversion, or bit-wise NOT, element-wise.`, type: `function` },
{ label: `np.left_shift(x1, x2)`, displayLabel: `np.left_shift(x1, x2[, out, where, casting, ...])`, info: `left_shift(x1, x2[, out, where, casting, ...]):\nShift the bits of an integer to the left.`, type: `function` },
{ label: `np.bitwise_left_shift(x1, x2)`, displayLabel: `np.bitwise_left_shift(x1, x2[, out, where, ...])`, info: `bitwise_left_shift(x1, x2[, out, where, ...]):\nShift the bits of an integer to the left.`, type: `function` },
{ label: `np.right_shift(x1, x2)`, displayLabel: `np.right_shift(x1, x2[, out, where, ...])`, info: `right_shift(x1, x2[, out, where, ...]):\nShift the bits of an integer to the right.`, type: `function` },
{ label: `np.bitwise_right_shift(x1, x2)`, displayLabel: `np.bitwise_right_shift(x1, x2[, out, where, ...])`, info: `bitwise_right_shift(x1, x2[, out, where, ...]):\nShift the bits of an integer to the right.`, type: `function` },
{ label: `np.packbits(a)`, displayLabel: `np.packbits(a[, axis, bitorder])`, info: `packbits(a[, axis, bitorder]):\nPacks the elements of a binary-valued array into bits in a uint8 array.`, type: `function` },
{ label: `np.unpackbits(a)`, displayLabel: `np.unpackbits(a[, axis, count, bitorder])`, info: `unpackbits(a[, axis, count, bitorder]):\nUnpacks elements of a uint8 array into a binary-valued output array.`, type: `function` },
{ label: `np.binary_repr(num)`, displayLabel: `np.binary_repr(num[, width])`, info: `binary_repr(num[, width]):\nReturn the binary representation of the input number as a string.`, type: `function` },
{ label: `np.dot(a, b)`, displayLabel: `np.dot(a, b[, out])`, info: `dot(a, b[, out]):\nDot product of two arrays.`, type: `function` },
{ label: `np.linalg.multi_dot(arrays, *)`, displayLabel: `np.linalg.multi_dot(arrays, *[, out])`, info: `linalg.multi_dot(arrays, *[, out]):\nCompute the dot product of two or more arrays in a single function call, while automatically selecting the fastest evaluation order.`, type: `function` },
{ label: `np.vdot(a, b)`, displayLabel: `np.vdot(a, b)`, info: `vdot(a, b):\nReturn the dot product of two vectors.`, type: `function` },
{ label: `np.vecdot(x1, x2)`, displayLabel: `np.vecdot(x1, x2[, out, casting, order, ...])`, info: `vecdot(x1, x2[, out, casting, order, ...]):\nVector dot product of two arrays.`, type: `function` },
{ label: `np.linalg.vecdot(x1, x2)`, displayLabel: `np.linalg.vecdot(x1, x2, *[, axis])`, info: `linalg.vecdot(x1, x2, *[, axis]):\nComputes the vector dot product.`, type: `function` },
{ label: `np.inner(a, b)`, displayLabel: `np.inner(a, b)`, info: `inner(a, b):\nInner product of two arrays.`, type: `function` },
{ label: `np.outer(a, b)`, displayLabel: `np.outer(a, b[, out])`, info: `outer(a, b[, out]):\nCompute the outer product of two vectors.`, type: `function` },
{ label: `np.matmul(x1, x2)`, displayLabel: `np.matmul(x1, x2[, out, casting, order, ...])`, info: `matmul(x1, x2[, out, casting, order, ...]):\nMatrix product of two arrays.`, type: `function` },
{ label: `np.linalg.matmul(x1, x2)`, displayLabel: `np.linalg.matmul(x1, x2)`, info: `linalg.matmul(x1, x2):\nComputes the matrix product.`, type: `function` },
{ label: `np.matvec(x1, x2)`, displayLabel: `np.matvec(x1, x2[, out, casting, order, ...])`, info: `matvec(x1, x2[, out, casting, order, ...]):\nMatrix-vector dot product of two arrays.`, type: `function` },
{ label: `np.vecmat(x1, x2)`, displayLabel: `np.vecmat(x1, x2[, out, casting, order, ...])`, info: `vecmat(x1, x2[, out, casting, order, ...]):\nVector-matrix dot product of two arrays.`, type: `function` },
{ label: `np.tensordot(a, b)`, displayLabel: `np.tensordot(a, b[, axes])`, info: `tensordot(a, b[, axes]):\nCompute tensor dot product along specified axes.`, type: `function` },
{ label: `np.linalg.tensordot(x1, x2)`, displayLabel: `np.linalg.tensordot(x1, x2, *[, axes])`, info: `linalg.tensordot(x1, x2, *[, axes]):\nCompute tensor dot product along specified axes.`, type: `function` },
{ label: `np.einsum(subscripts, *operands)`, displayLabel: `np.einsum(subscripts, *operands[, out, dtype, ...])`, info: `einsum(subscripts, *operands[, out, dtype, ...]):\nEvaluates the Einstein summation convention on the operands.`, type: `function` },
{ label: `np.einsum_path(subscripts, *operands)`, displayLabel: `np.einsum_path(subscripts, *operands[, optimize])`, info: `einsum_path(subscripts, *operands[, optimize]):\nEvaluates the lowest cost contraction order for an einsum expression by considering the creation of intermediate arrays.`, type: `function` },
{ label: `np.linalg.matrix_power(a, n)`, displayLabel: `np.linalg.matrix_power(a, n)`, info: `linalg.matrix_power(a, n):\nRaise a square matrix to the (integer) power n.`, type: `function` },
{ label: `np.kron(a, b)`, displayLabel: `np.kron(a, b)`, info: `kron(a, b):\nKronecker product of two arrays.`, type: `function` },
{ label: `np.linalg.cross(x1, x2)`, displayLabel: `np.linalg.cross(x1, x2, *[, axis])`, info: `linalg.cross(x1, x2, *[, axis]):\nReturns the cross product of 3-element vectors.`, type: `function` },
{ label: `np.linalg.cholesky(a)`, displayLabel: `np.linalg.cholesky(a, *[, upper])`, info: `linalg.cholesky(a, *[, upper]):\nCholesky decomposition.`, type: `function` },
{ label: `np.linalg.outer(x1, x2)`, displayLabel: `np.linalg.outer(x1, x2)`, info: `linalg.outer(x1, x2):\nCompute the outer product of two vectors.`, type: `function` },
{ label: `np.linalg.qr(a)`, displayLabel: `np.linalg.qr(a[, mode])`, info: `linalg.qr(a[, mode]):\nCompute the qr factorization of a matrix.`, type: `function` },
{ label: `np.linalg.svd(a)`, displayLabel: `np.linalg.svd(a[, full_matrices, compute_uv, ...])`, info: `linalg.svd(a[, full_matrices, compute_uv, ...]):\nSingular Value Decomposition.`, type: `function` },
{ label: `np.linalg.svdvals(x)`, displayLabel: `np.linalg.svdvals(x)`, info: `linalg.svdvals(x):\nReturns the singular values of a matrix (or a stack of matrices) x.`, type: `function` },
{ label: `np.linalg.eig(a)`, displayLabel: `np.linalg.eig(a)`, info: `linalg.eig(a):\nCompute the eigenvalues and right eigenvectors of a square array.`, type: `function` },
{ label: `np.linalg.eigh(a)`, displayLabel: `np.linalg.eigh(a[, UPLO])`, info: `linalg.eigh(a[, UPLO]):\nReturn the eigenvalues and eigenvectors of a complex Hermitian (conjugate symmetric) or a real symmetric matrix.`, type: `function` },
{ label: `np.linalg.eigvals(a)`, displayLabel: `np.linalg.eigvals(a)`, info: `linalg.eigvals(a):\nCompute the eigenvalues of a general matrix.`, type: `function` },
{ label: `np.linalg.eigvalsh(a)`, displayLabel: `np.linalg.eigvalsh(a[, UPLO])`, info: `linalg.eigvalsh(a[, UPLO]):\nCompute the eigenvalues of a complex Hermitian or real symmetric matrix.`, type: `function` },
{ label: `np.linalg.norm(x)`, displayLabel: `np.linalg.norm(x[, ord, axis, keepdims])`, info: `linalg.norm(x[, ord, axis, keepdims]):\nMatrix or vector norm.`, type: `function` },
{ label: `np.linalg.matrix_norm(x)`, displayLabel: `np.linalg.matrix_norm(x, *[, keepdims, ord])`, info: `linalg.matrix_norm(x, *[, keepdims, ord]):\nComputes the matrix norm of a matrix (or a stack of matrices) x.`, type: `function` },
{ label: `np.linalg.vector_norm(x)`, displayLabel: `np.linalg.vector_norm(x, *[, axis, ...])`, info: `linalg.vector_norm(x, *[, axis, ...]):\nComputes the vector norm of a vector (or batch of vectors) x.`, type: `function` },
{ label: `np.linalg.cond(x)`, displayLabel: `np.linalg.cond(x[, p])`, info: `linalg.cond(x[, p]):\nCompute the condition number of a matrix.`, type: `function` },
{ label: `np.linalg.det(a)`, displayLabel: `np.linalg.det(a)`, info: `linalg.det(a):\nCompute the determinant of an array.`, type: `function` },
{ label: `np.linalg.matrix_rank(A)`, displayLabel: `np.linalg.matrix_rank(A[, tol, hermitian, rtol])`, info: `linalg.matrix_rank(A[, tol, hermitian, rtol]):\nReturn matrix rank of array using SVD method`, type: `function` },
{ label: `np.linalg.slogdet(a)`, displayLabel: `np.linalg.slogdet(a)`, info: `linalg.slogdet(a):\nCompute the sign and (natural) logarithm of the determinant of an array.`, type: `function` },
{ label: `np.trace(a)`, displayLabel: `np.trace(a[, offset, axis1, axis2, dtype, out])`, info: `trace(a[, offset, axis1, axis2, dtype, out]):\nReturn the sum along diagonals of the array.`, type: `function` },
{ label: `np.linalg.trace(x)`, displayLabel: `np.linalg.trace(x, *[, offset, dtype])`, info: `linalg.trace(x, *[, offset, dtype]):\nReturns the sum along the specified diagonals of a matrix (or a stack of matrices) x.`, type: `function` },
{ label: `np.linalg.solve(a, b)`, displayLabel: `np.linalg.solve(a, b)`, info: `linalg.solve(a, b):\nSolve a linear matrix equation, or system of linear scalar equations.`, type: `function` },
{ label: `np.linalg.tensorsolve(a, b)`, displayLabel: `np.linalg.tensorsolve(a, b[, axes])`, info: `linalg.tensorsolve(a, b[, axes]):\nSolve the tensor equation a x = b for x.`, type: `function` },
{ label: `np.linalg.lstsq(a, b)`, displayLabel: `np.linalg.lstsq(a, b[, rcond])`, info: `linalg.lstsq(a, b[, rcond]):\nReturn the least-squares solution to a linear matrix equation.`, type: `function` },
{ label: `np.linalg.inv(a)`, displayLabel: `np.linalg.inv(a)`, info: `linalg.inv(a):\nCompute the inverse of a matrix.`, type: `function` },
{ label: `np.linalg.pinv(a)`, displayLabel: `np.linalg.pinv(a[, rcond, hermitian, rtol])`, info: `linalg.pinv(a[, rcond, hermitian, rtol]):\nCompute the (Moore-Penrose) pseudo-inverse of a matrix.`, type: `function` },
{ label: `np.linalg.tensorinv(a)`, displayLabel: `np.linalg.tensorinv(a[, ind])`, info: `linalg.tensorinv(a[, ind]):\nCompute the 'inverse' of an N-dimensional array.`, type: `function` },
{ label: `np.diagonal(a)`, displayLabel: `np.diagonal(a[, offset, axis1, axis2])`, info: `diagonal(a[, offset, axis1, axis2]):\nReturn specified diagonals.`, type: `function` },
{ label: `np.linalg.diagonal(x)`, displayLabel: `np.linalg.diagonal(x, *[, offset])`, info: `linalg.diagonal(x, *[, offset]):\nReturns specified diagonals of a matrix (or a stack of matrices) x.`, type: `function` },
{ label: `np.linalg.matrix_transpose(x)`, displayLabel: `np.linalg.matrix_transpose(x)`, info: `linalg.matrix_transpose(x):\nTransposes a matrix (or a stack of matrices) x.`, type: `function` },
{ label: `np.fft(a)`, displayLabel: `np.fft(a[, n, axis, norm, out])`, info: `fft(a[, n, axis, norm, out]):\nCompute the one-dimensional discrete Fourier Transform.`, type: `function` },
{ label: `np.ifft(a)`, displayLabel: `np.ifft(a[, n, axis, norm, out])`, info: `ifft(a[, n, axis, norm, out]):\nCompute the one-dimensional inverse discrete Fourier Transform.`, type: `function` },
{ label: `np.fft2(a)`, displayLabel: `np.fft2(a[, s, axes, norm, out])`, info: `fft2(a[, s, axes, norm, out]):\nCompute the 2-dimensional discrete Fourier Transform.`, type: `function` },
{ label: `np.ifft2(a)`, displayLabel: `np.ifft2(a[, s, axes, norm, out])`, info: `ifft2(a[, s, axes, norm, out]):\nCompute the 2-dimensional inverse discrete Fourier Transform.`, type: `function` },
{ label: `np.fftn(a)`, displayLabel: `np.fftn(a[, s, axes, norm, out])`, info: `fftn(a[, s, axes, norm, out]):\nCompute the N-dimensional discrete Fourier Transform.`, type: `function` },
{ label: `np.ifftn(a)`, displayLabel: `np.ifftn(a[, s, axes, norm, out])`, info: `ifftn(a[, s, axes, norm, out]):\nCompute the N-dimensional inverse discrete Fourier Transform.`, type: `function` },
{ label: `np.rfft(a)`, displayLabel: `np.rfft(a[, n, axis, norm, out])`, info: `rfft(a[, n, axis, norm, out]):\nCompute the one-dimensional discrete Fourier Transform for real input.`, type: `function` },
{ label: `np.irfft(a)`, displayLabel: `np.irfft(a[, n, axis, norm, out])`, info: `irfft(a[, n, axis, norm, out]):\nComputes the inverse of rfft.`, type: `function` },
{ label: `np.rfft2(a)`, displayLabel: `np.rfft2(a[, s, axes, norm, out])`, info: `rfft2(a[, s, axes, norm, out]):\nCompute the 2-dimensional FFT of a real array.`, type: `function` },
{ label: `np.irfft2(a)`, displayLabel: `np.irfft2(a[, s, axes, norm, out])`, info: `irfft2(a[, s, axes, norm, out]):\nComputes the inverse of rfft2.`, type: `function` },
{ label: `np.rfftn(a)`, displayLabel: `np.rfftn(a[, s, axes, norm, out])`, info: `rfftn(a[, s, axes, norm, out]):\nCompute the N-dimensional discrete Fourier Transform for real input.`, type: `function` },
{ label: `np.irfftn(a)`, displayLabel: `np.irfftn(a[, s, axes, norm, out])`, info: `irfftn(a[, s, axes, norm, out]):\nComputes the inverse of rfftn.`, type: `function` },
{ label: `np.hfft(a)`, displayLabel: `np.hfft(a[, n, axis, norm, out])`, info: `hfft(a[, n, axis, norm, out]):\nCompute the FFT of a signal that has Hermitian symmetry, i.e., a real spectrum.`, type: `function` },
{ label: `np.ihfft(a)`, displayLabel: `np.ihfft(a[, n, axis, norm, out])`, info: `ihfft(a[, n, axis, norm, out]):\nCompute the inverse FFT of a signal that has Hermitian symmetry.`, type: `function` },
{ label: `np.fftfreq(n)`, displayLabel: `np.fftfreq(n[, d, device])`, info: `fftfreq(n[, d, device]):\nReturn the Discrete Fourier Transform sample frequencies.`, type: `function` },
{ label: `np.rfftfreq(n)`, displayLabel: `np.rfftfreq(n[, d, device])`, info: `rfftfreq(n[, d, device]):\nReturn the Discrete Fourier Transform sample frequencies (for usage with rfft, irfft).`, type: `function` },
{ label: `np.fftshift(x)`, displayLabel: `np.fftshift(x[, axes])`, info: `fftshift(x[, axes]):\nShift the zero-frequency component to the center of the spectrum.`, type: `function` },
{ label: `np.ifftshift(x)`, displayLabel: `np.ifftshift(x[, axes])`, info: `ifftshift(x[, axes]):\nThe inverse of fftshift.`, type: `function` },
]

export const npAutocomplete = wrapAutocomplete(/np\..*/, npCompletions);